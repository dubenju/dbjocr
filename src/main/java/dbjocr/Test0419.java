package dbjocr;

import java.awt.image.BufferedImage;
import java.io.File;

import javax.imageio.ImageIO;
/**
 * https://blog.csdn.net/mieleizhi0522/article/details/79577519
 * @author benju
 *
 */
public class Test0419 {

	public static void main(String[] args) {
		String  infile =  "./input/sudoku2";
		String outfile = "./output/sudoku2";
		try {
			/*
			 * 0.载入图像。
			 */
			BufferedImage bimage = ImageIO.read(new File(infile + ".jpg"));
			
			/*
			 * 1.图像预处理。
			 * 从RGB空间向HSV空间的转换，H是色相（hue）,S是饱和度（saturation），V是色调(value）。
			 */
			
			/*
			 * 2.图像灰度化
			 * 在竖直方向上投影计算出高度
			 * 在水平方向上投影计算出宽度
			 * 
			 */
			
			/*
			 * 3.倾斜校正
			 * 车牌分割出来之后不一定是一个矩形，因为由于拍摄角度问题，可能倾斜，
			 * 所以可能是个平行四边形，这个时候就要用到校正了，这里用的方法是，
			 * 统计车牌两端的字符像素的平均加权高度，如果两边的平均高度一样，
			 * 那么就证明是不倾斜，否则是，如果倾斜，就根据斜率重新组织图像，
			 * 最后再用膨胀操作，细化字符
			 */
			
			/*
			 * 4.字符分割
			 * 统计车牌中每列的白色像素点个数之和，个数最多的列证明是字符之间的空隙，
			 * 也就是要分割的位置，同理，水平方向也这样做，可以去除原车牌头上的两个螺丝钉的痕迹
			 */
			
			/*
			 * 5.归一化细化
			 * 就是先将分割出的每个字符都变换到20*40的大小，这样可以统一，便于识别，
			 * 细化就是让字符笔画变细，每个笔画宽度为一个像素
			 */
			
			/*
			 * 6.特征提取
			 * 特征提取包括提取对样本字符的特征提取和对分割出来的字符的特征提取，
			 * 通过比对分割出来的字符的特征与样本字符的特征来判断字符属于哪一个字符，
			 * 然后输出结果，其中这个特征怎么提取是关键，这里采用两种统计特征，
			 * 一种是网格特征，由于模板图像都是20像素*40像素大小的，
			 * 所以将带识别的字符也归一化为模板图像大小，
			 * 然后把图像分成5*5=25个小格子，统计每一个格子里白色像素的个数，
			 * 形成一个25维的矢量，
			 * 
			 * 另外一种特征是交叉点，在水平方向以及垂直方向五等分的地方，
			 * 做水平或者垂直线穿过数字，看其与数字相交的次数，
			 * 这样又获得了8个数值，加起一共33维。
			 */
			
			/*
			 * 7.字符识别
			 * 字符识别就是在步骤6中讲的 通过比对分割出来的字符的特征
			 * 与样本字符的特征来判断字符属于哪一个字符，然后输出结果，
			 * 但是问题来了，这样识别出来的并不精确，很多字符都能识别错，
			 * 然后我就在找一些漏洞，
			 * 发现分割出来的字符和样本的字符都能用眼睛看出来是什么，
			 * 但是它们的位置有偏差，比如，一个“F”可能在样本中，
			 * 它是在图片的正中间，但是分割出来的字符“F”
			 * 可能就是在一张图片的左边，或者左上边，
			 * 有时候是分割出来的字符在图片正中间，而样本字符是在图片的一边，
			 * 就像上面所说的那样，所有我要重新做一下规范，
			 * 也就是把样本图片和分割出来的图片都让字符的长和宽“充满”20*40的图片，
			 * you konw that，就像上图左边的图片一样。
			 * 那接下来应该怎么弄呢，想必你已经清楚了，
			 * 也就是模仿第2步的“车牌定位”这一步，
			 * 对第5步之后的图像进行“字符定位”我姑且这样说，
			 * 就是把多余的黑背景去掉，也就达到目的了。事实证明，正确率着实提高了不少。
			 */
        } catch (Exception e) {
            e.printStackTrace();
        }
	}

}
